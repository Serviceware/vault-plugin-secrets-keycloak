// Code generated by mockery v2.13.1. DO NOT EDIT.

package mocks

import (
	context "context"
	io "io"

	gocloak "github.com/Nerzal/gocloak/v11"

	jwt "github.com/golang-jwt/jwt/v4"

	mock "github.com/stretchr/testify/mock"

	resty "github.com/go-resty/resty/v2"
)

// GoCloak is an autogenerated mock type for the GoCloak type
type GoCloak struct {
	mock.Mock
}

// AddClientRoleComposite provides a mock function with given fields: ctx, token, realm, roleID, roles
func (_m *GoCloak) AddClientRoleComposite(ctx context.Context, token string, realm string, roleID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, roleID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, roleID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddClientRoleToGroup provides a mock function with given fields: ctx, token, realm, idOfClient, groupID, roles
func (_m *GoCloak) AddClientRoleToGroup(ctx context.Context, token string, realm string, idOfClient string, groupID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClient, groupID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, groupID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddClientRoleToUser provides a mock function with given fields: ctx, token, realm, idOfClient, userID, roles
func (_m *GoCloak) AddClientRoleToUser(ctx context.Context, token string, realm string, idOfClient string, userID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClient, userID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, userID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddDefaultGroup provides a mock function with given fields: ctx, accessToken, realm, groupID
func (_m *GoCloak) AddDefaultGroup(ctx context.Context, accessToken string, realm string, groupID string) error {
	ret := _m.Called(ctx, accessToken, realm, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddDefaultScopeToClient provides a mock function with given fields: ctx, token, realm, idOfClient, scopeID
func (_m *GoCloak) AddDefaultScopeToClient(ctx context.Context, token string, realm string, idOfClient string, scopeID string) error {
	ret := _m.Called(ctx, token, realm, idOfClient, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddOptionalScopeToClient provides a mock function with given fields: ctx, token, realm, idOfClient, scopeID
func (_m *GoCloak) AddOptionalScopeToClient(ctx context.Context, token string, realm string, idOfClient string, scopeID string) error {
	ret := _m.Called(ctx, token, realm, idOfClient, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddRealmRoleComposite provides a mock function with given fields: ctx, token, realm, roleName, roles
func (_m *GoCloak) AddRealmRoleComposite(ctx context.Context, token string, realm string, roleName string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, roleName, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, roleName, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddRealmRoleToGroup provides a mock function with given fields: ctx, token, realm, groupID, roles
func (_m *GoCloak) AddRealmRoleToGroup(ctx context.Context, token string, realm string, groupID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, groupID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, groupID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddRealmRoleToUser provides a mock function with given fields: ctx, token, realm, userID, roles
func (_m *GoCloak) AddRealmRoleToUser(ctx context.Context, token string, realm string, userID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, userID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, userID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddUserToGroup provides a mock function with given fields: ctx, token, realm, userID, groupID
func (_m *GoCloak) AddUserToGroup(ctx context.Context, token string, realm string, userID string, groupID string) error {
	ret := _m.Called(ctx, token, realm, userID, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, userID, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClearKeysCache provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) ClearKeysCache(ctx context.Context, token string, realm string) error {
	ret := _m.Called(ctx, token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClearRealmCache provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) ClearRealmCache(ctx context.Context, token string, realm string) error {
	ret := _m.Called(ctx, token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClearUserCache provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) ClearUserCache(ctx context.Context, token string, realm string) error {
	ret := _m.Called(ctx, token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateAuthenticationExecution provides a mock function with given fields: ctx, token, realm, flow, execution
func (_m *GoCloak) CreateAuthenticationExecution(ctx context.Context, token string, realm string, flow string, execution gocloak.CreateAuthenticationExecutionRepresentation) error {
	ret := _m.Called(ctx, token, realm, flow, execution)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.CreateAuthenticationExecutionRepresentation) error); ok {
		r0 = rf(ctx, token, realm, flow, execution)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateAuthenticationExecutionFlow provides a mock function with given fields: ctx, token, realm, flow, execution
func (_m *GoCloak) CreateAuthenticationExecutionFlow(ctx context.Context, token string, realm string, flow string, execution gocloak.CreateAuthenticationExecutionFlowRepresentation) error {
	ret := _m.Called(ctx, token, realm, flow, execution)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.CreateAuthenticationExecutionFlowRepresentation) error); ok {
		r0 = rf(ctx, token, realm, flow, execution)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateAuthenticationFlow provides a mock function with given fields: ctx, token, realm, flow
func (_m *GoCloak) CreateAuthenticationFlow(ctx context.Context, token string, realm string, flow gocloak.AuthenticationFlowRepresentation) error {
	ret := _m.Called(ctx, token, realm, flow)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.AuthenticationFlowRepresentation) error); ok {
		r0 = rf(ctx, token, realm, flow)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateChildGroup provides a mock function with given fields: ctx, token, realm, groupID, group
func (_m *GoCloak) CreateChildGroup(ctx context.Context, token string, realm string, groupID string, group gocloak.Group) (string, error) {
	ret := _m.Called(ctx, token, realm, groupID, group)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.Group) string); ok {
		r0 = rf(ctx, token, realm, groupID, group)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.Group) error); ok {
		r1 = rf(ctx, token, realm, groupID, group)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClient provides a mock function with given fields: ctx, accessToken, realm, newClient
func (_m *GoCloak) CreateClient(ctx context.Context, accessToken string, realm string, newClient gocloak.Client) (string, error) {
	ret := _m.Called(ctx, accessToken, realm, newClient)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.Client) string); ok {
		r0 = rf(ctx, accessToken, realm, newClient)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.Client) error); ok {
		r1 = rf(ctx, accessToken, realm, newClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientProtocolMapper provides a mock function with given fields: ctx, token, realm, idOfClient, mapper
func (_m *GoCloak) CreateClientProtocolMapper(ctx context.Context, token string, realm string, idOfClient string, mapper gocloak.ProtocolMapperRepresentation) (string, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, mapper)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ProtocolMapperRepresentation) string); ok {
		r0 = rf(ctx, token, realm, idOfClient, mapper)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.ProtocolMapperRepresentation) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, mapper)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientRepresentation provides a mock function with given fields: ctx, realm
func (_m *GoCloak) CreateClientRepresentation(ctx context.Context, realm string) (*gocloak.Client, error) {
	ret := _m.Called(ctx, realm)

	var r0 *gocloak.Client
	if rf, ok := ret.Get(0).(func(context.Context, string) *gocloak.Client); ok {
		r0 = rf(ctx, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientRole provides a mock function with given fields: ctx, accessToken, realm, idOfClient, role
func (_m *GoCloak) CreateClientRole(ctx context.Context, accessToken string, realm string, idOfClient string, role gocloak.Role) (string, error) {
	ret := _m.Called(ctx, accessToken, realm, idOfClient, role)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.Role) string); ok {
		r0 = rf(ctx, accessToken, realm, idOfClient, role)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.Role) error); ok {
		r1 = rf(ctx, accessToken, realm, idOfClient, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientScope provides a mock function with given fields: ctx, accessToken, realm, scope
func (_m *GoCloak) CreateClientScope(ctx context.Context, accessToken string, realm string, scope gocloak.ClientScope) (string, error) {
	ret := _m.Called(ctx, accessToken, realm, scope)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.ClientScope) string); ok {
		r0 = rf(ctx, accessToken, realm, scope)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.ClientScope) error); ok {
		r1 = rf(ctx, accessToken, realm, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientScopeMappingsClientRoles provides a mock function with given fields: ctx, token, realm, idOfClient, idOfSelectedClient, roles
func (_m *GoCloak) CreateClientScopeMappingsClientRoles(ctx context.Context, token string, realm string, idOfClient string, idOfSelectedClient string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClient, idOfSelectedClient, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, idOfSelectedClient, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateClientScopeMappingsRealmRoles provides a mock function with given fields: ctx, token, realm, idOfClient, roles
func (_m *GoCloak) CreateClientScopeMappingsRealmRoles(ctx context.Context, token string, realm string, idOfClient string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClient, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateClientScopeProtocolMapper provides a mock function with given fields: ctx, accessToken, realm, scopeID, protocolMapper
func (_m *GoCloak) CreateClientScopeProtocolMapper(ctx context.Context, accessToken string, realm string, scopeID string, protocolMapper gocloak.ProtocolMappers) (string, error) {
	ret := _m.Called(ctx, accessToken, realm, scopeID, protocolMapper)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ProtocolMappers) string); ok {
		r0 = rf(ctx, accessToken, realm, scopeID, protocolMapper)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.ProtocolMappers) error); ok {
		r1 = rf(ctx, accessToken, realm, scopeID, protocolMapper)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientScopesScopeMappingsClientRoles provides a mock function with given fields: ctx, token, realm, idOfClientScope, idOfClient, roles
func (_m *GoCloak) CreateClientScopesScopeMappingsClientRoles(ctx context.Context, token string, realm string, idOfClientScope string, idOfClient string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClientScope, idOfClient, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClientScope, idOfClient, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateClientScopesScopeMappingsRealmRoles provides a mock function with given fields: ctx, token, realm, idOfClientScope, roles
func (_m *GoCloak) CreateClientScopesScopeMappingsRealmRoles(ctx context.Context, token string, realm string, idOfClientScope string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClientScope, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClientScope, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateComponent provides a mock function with given fields: ctx, accessToken, realm, component
func (_m *GoCloak) CreateComponent(ctx context.Context, accessToken string, realm string, component gocloak.Component) (string, error) {
	ret := _m.Called(ctx, accessToken, realm, component)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.Component) string); ok {
		r0 = rf(ctx, accessToken, realm, component)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.Component) error); ok {
		r1 = rf(ctx, accessToken, realm, component)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGroup provides a mock function with given fields: ctx, accessToken, realm, group
func (_m *GoCloak) CreateGroup(ctx context.Context, accessToken string, realm string, group gocloak.Group) (string, error) {
	ret := _m.Called(ctx, accessToken, realm, group)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.Group) string); ok {
		r0 = rf(ctx, accessToken, realm, group)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.Group) error); ok {
		r1 = rf(ctx, accessToken, realm, group)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIdentityProvider provides a mock function with given fields: ctx, token, realm, providerRep
func (_m *GoCloak) CreateIdentityProvider(ctx context.Context, token string, realm string, providerRep gocloak.IdentityProviderRepresentation) (string, error) {
	ret := _m.Called(ctx, token, realm, providerRep)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.IdentityProviderRepresentation) string); ok {
		r0 = rf(ctx, token, realm, providerRep)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.IdentityProviderRepresentation) error); ok {
		r1 = rf(ctx, token, realm, providerRep)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIdentityProviderMapper provides a mock function with given fields: ctx, token, realm, alias, mapper
func (_m *GoCloak) CreateIdentityProviderMapper(ctx context.Context, token string, realm string, alias string, mapper gocloak.IdentityProviderMapper) (string, error) {
	ret := _m.Called(ctx, token, realm, alias, mapper)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.IdentityProviderMapper) string); ok {
		r0 = rf(ctx, token, realm, alias, mapper)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.IdentityProviderMapper) error); ok {
		r1 = rf(ctx, token, realm, alias, mapper)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePermission provides a mock function with given fields: ctx, token, realm, idOfClient, permission
func (_m *GoCloak) CreatePermission(ctx context.Context, token string, realm string, idOfClient string, permission gocloak.PermissionRepresentation) (*gocloak.PermissionRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, permission)

	var r0 *gocloak.PermissionRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.PermissionRepresentation) *gocloak.PermissionRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, permission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PermissionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.PermissionRepresentation) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, permission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePermissionTicket provides a mock function with given fields: ctx, token, realm, permissions
func (_m *GoCloak) CreatePermissionTicket(ctx context.Context, token string, realm string, permissions []gocloak.CreatePermissionTicketParams) (*gocloak.PermissionTicketResponseRepresentation, error) {
	ret := _m.Called(ctx, token, realm, permissions)

	var r0 *gocloak.PermissionTicketResponseRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []gocloak.CreatePermissionTicketParams) *gocloak.PermissionTicketResponseRepresentation); ok {
		r0 = rf(ctx, token, realm, permissions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PermissionTicketResponseRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, []gocloak.CreatePermissionTicketParams) error); ok {
		r1 = rf(ctx, token, realm, permissions)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePolicy provides a mock function with given fields: ctx, token, realm, idOfClient, policy
func (_m *GoCloak) CreatePolicy(ctx context.Context, token string, realm string, idOfClient string, policy gocloak.PolicyRepresentation) (*gocloak.PolicyRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, policy)

	var r0 *gocloak.PolicyRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.PolicyRepresentation) *gocloak.PolicyRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, policy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.PolicyRepresentation) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, policy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRealm provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) CreateRealm(ctx context.Context, token string, realm gocloak.RealmRepresentation) (string, error) {
	ret := _m.Called(ctx, token, realm)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, gocloak.RealmRepresentation) string); ok {
		r0 = rf(ctx, token, realm)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, gocloak.RealmRepresentation) error); ok {
		r1 = rf(ctx, token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRealmRole provides a mock function with given fields: ctx, token, realm, role
func (_m *GoCloak) CreateRealmRole(ctx context.Context, token string, realm string, role gocloak.Role) (string, error) {
	ret := _m.Called(ctx, token, realm, role)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.Role) string); ok {
		r0 = rf(ctx, token, realm, role)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.Role) error); ok {
		r1 = rf(ctx, token, realm, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResource provides a mock function with given fields: ctx, token, realm, idOfClient, resource
func (_m *GoCloak) CreateResource(ctx context.Context, token string, realm string, idOfClient string, resource gocloak.ResourceRepresentation) (*gocloak.ResourceRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, resource)

	var r0 *gocloak.ResourceRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ResourceRepresentation) *gocloak.ResourceRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, resource)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.ResourceRepresentation) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, resource)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResourceClient provides a mock function with given fields: ctx, token, realm, resource
func (_m *GoCloak) CreateResourceClient(ctx context.Context, token string, realm string, resource gocloak.ResourceRepresentation) (*gocloak.ResourceRepresentation, error) {
	ret := _m.Called(ctx, token, realm, resource)

	var r0 *gocloak.ResourceRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.ResourceRepresentation) *gocloak.ResourceRepresentation); ok {
		r0 = rf(ctx, token, realm, resource)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.ResourceRepresentation) error); ok {
		r1 = rf(ctx, token, realm, resource)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResourcePolicy provides a mock function with given fields: ctx, token, realm, resourceID, policy
func (_m *GoCloak) CreateResourcePolicy(ctx context.Context, token string, realm string, resourceID string, policy gocloak.ResourcePolicyRepresentation) (*gocloak.ResourcePolicyRepresentation, error) {
	ret := _m.Called(ctx, token, realm, resourceID, policy)

	var r0 *gocloak.ResourcePolicyRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ResourcePolicyRepresentation) *gocloak.ResourcePolicyRepresentation); ok {
		r0 = rf(ctx, token, realm, resourceID, policy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ResourcePolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.ResourcePolicyRepresentation) error); ok {
		r1 = rf(ctx, token, realm, resourceID, policy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateScope provides a mock function with given fields: ctx, token, realm, idOfClient, scope
func (_m *GoCloak) CreateScope(ctx context.Context, token string, realm string, idOfClient string, scope gocloak.ScopeRepresentation) (*gocloak.ScopeRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, scope)

	var r0 *gocloak.ScopeRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ScopeRepresentation) *gocloak.ScopeRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ScopeRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.ScopeRepresentation) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, token, realm, user
func (_m *GoCloak) CreateUser(ctx context.Context, token string, realm string, user gocloak.User) (string, error) {
	ret := _m.Called(ctx, token, realm, user)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.User) string); ok {
		r0 = rf(ctx, token, realm, user)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.User) error); ok {
		r1 = rf(ctx, token, realm, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUserFederatedIdentity provides a mock function with given fields: ctx, token, realm, userID, providerID, federatedIdentityRep
func (_m *GoCloak) CreateUserFederatedIdentity(ctx context.Context, token string, realm string, userID string, providerID string, federatedIdentityRep gocloak.FederatedIdentityRepresentation) error {
	ret := _m.Called(ctx, token, realm, userID, providerID, federatedIdentityRep)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, gocloak.FederatedIdentityRepresentation) error); ok {
		r0 = rf(ctx, token, realm, userID, providerID, federatedIdentityRep)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DecodeAccessToken provides a mock function with given fields: ctx, accessToken, realm
func (_m *GoCloak) DecodeAccessToken(ctx context.Context, accessToken string, realm string) (*jwt.Token, *jwt.MapClaims, error) {
	ret := _m.Called(ctx, accessToken, realm)

	var r0 *jwt.Token
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *jwt.Token); ok {
		r0 = rf(ctx, accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jwt.Token)
		}
	}

	var r1 *jwt.MapClaims
	if rf, ok := ret.Get(1).(func(context.Context, string, string) *jwt.MapClaims); ok {
		r1 = rf(ctx, accessToken, realm)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*jwt.MapClaims)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = rf(ctx, accessToken, realm)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DecodeAccessTokenCustomClaims provides a mock function with given fields: ctx, accessToken, realm, claims
func (_m *GoCloak) DecodeAccessTokenCustomClaims(ctx context.Context, accessToken string, realm string, claims jwt.Claims) (*jwt.Token, error) {
	ret := _m.Called(ctx, accessToken, realm, claims)

	var r0 *jwt.Token
	if rf, ok := ret.Get(0).(func(context.Context, string, string, jwt.Claims) *jwt.Token); ok {
		r0 = rf(ctx, accessToken, realm, claims)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jwt.Token)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, jwt.Claims) error); ok {
		r1 = rf(ctx, accessToken, realm, claims)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAuthenticationExecution provides a mock function with given fields: ctx, token, realm, executionID
func (_m *GoCloak) DeleteAuthenticationExecution(ctx context.Context, token string, realm string, executionID string) error {
	ret := _m.Called(ctx, token, realm, executionID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, executionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteAuthenticationFlow provides a mock function with given fields: ctx, token, realm, flowID
func (_m *GoCloak) DeleteAuthenticationFlow(ctx context.Context, token string, realm string, flowID string) error {
	ret := _m.Called(ctx, token, realm, flowID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, flowID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClient provides a mock function with given fields: ctx, accessToken, realm, idOfClient
func (_m *GoCloak) DeleteClient(ctx context.Context, accessToken string, realm string, idOfClient string) error {
	ret := _m.Called(ctx, accessToken, realm, idOfClient)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, idOfClient)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientProtocolMapper provides a mock function with given fields: ctx, token, realm, idOfClient, mapperID
func (_m *GoCloak) DeleteClientProtocolMapper(ctx context.Context, token string, realm string, idOfClient string, mapperID string) error {
	ret := _m.Called(ctx, token, realm, idOfClient, mapperID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, mapperID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientRepresentation provides a mock function with given fields: ctx, accessToken, realm, clientID
func (_m *GoCloak) DeleteClientRepresentation(ctx context.Context, accessToken string, realm string, clientID string) error {
	ret := _m.Called(ctx, accessToken, realm, clientID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, clientID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientRole provides a mock function with given fields: ctx, accessToken, realm, idOfClient, roleName
func (_m *GoCloak) DeleteClientRole(ctx context.Context, accessToken string, realm string, idOfClient string, roleName string) error {
	ret := _m.Called(ctx, accessToken, realm, idOfClient, roleName)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, idOfClient, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientRoleComposite provides a mock function with given fields: ctx, token, realm, roleID, roles
func (_m *GoCloak) DeleteClientRoleComposite(ctx context.Context, token string, realm string, roleID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, roleID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, roleID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientRoleFromGroup provides a mock function with given fields: ctx, token, realm, idOfClient, groupID, roles
func (_m *GoCloak) DeleteClientRoleFromGroup(ctx context.Context, token string, realm string, idOfClient string, groupID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClient, groupID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, groupID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientRoleFromUser provides a mock function with given fields: ctx, token, realm, idOfClient, userID, roles
func (_m *GoCloak) DeleteClientRoleFromUser(ctx context.Context, token string, realm string, idOfClient string, userID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClient, userID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, userID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientScope provides a mock function with given fields: ctx, accessToken, realm, scopeID
func (_m *GoCloak) DeleteClientScope(ctx context.Context, accessToken string, realm string, scopeID string) error {
	ret := _m.Called(ctx, accessToken, realm, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientScopeMappingsClientRoles provides a mock function with given fields: ctx, token, realm, idOfClient, idOfSelectedClient, roles
func (_m *GoCloak) DeleteClientScopeMappingsClientRoles(ctx context.Context, token string, realm string, idOfClient string, idOfSelectedClient string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClient, idOfSelectedClient, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, idOfSelectedClient, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientScopeMappingsRealmRoles provides a mock function with given fields: ctx, token, realm, idOfClient, roles
func (_m *GoCloak) DeleteClientScopeMappingsRealmRoles(ctx context.Context, token string, realm string, idOfClient string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClient, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientScopeProtocolMapper provides a mock function with given fields: ctx, accessToken, realm, scopeID, protocolMapperID
func (_m *GoCloak) DeleteClientScopeProtocolMapper(ctx context.Context, accessToken string, realm string, scopeID string, protocolMapperID string) error {
	ret := _m.Called(ctx, accessToken, realm, scopeID, protocolMapperID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, scopeID, protocolMapperID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientScopesScopeMappingsClientRoles provides a mock function with given fields: ctx, token, realm, idOfClientScope, ifOfClient, roles
func (_m *GoCloak) DeleteClientScopesScopeMappingsClientRoles(ctx context.Context, token string, realm string, idOfClientScope string, ifOfClient string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClientScope, ifOfClient, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClientScope, ifOfClient, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientScopesScopeMappingsRealmRoles provides a mock function with given fields: ctx, token, realm, idOfClientScope, roles
func (_m *GoCloak) DeleteClientScopesScopeMappingsRealmRoles(ctx context.Context, token string, realm string, idOfClientScope string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, idOfClientScope, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, idOfClientScope, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteComponent provides a mock function with given fields: ctx, accessToken, realm, componentID
func (_m *GoCloak) DeleteComponent(ctx context.Context, accessToken string, realm string, componentID string) error {
	ret := _m.Called(ctx, accessToken, realm, componentID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, componentID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteCredentials provides a mock function with given fields: ctx, token, realm, UserID, CredentialID
func (_m *GoCloak) DeleteCredentials(ctx context.Context, token string, realm string, UserID string, CredentialID string) error {
	ret := _m.Called(ctx, token, realm, UserID, CredentialID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, UserID, CredentialID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGroup provides a mock function with given fields: ctx, accessToken, realm, groupID
func (_m *GoCloak) DeleteGroup(ctx context.Context, accessToken string, realm string, groupID string) error {
	ret := _m.Called(ctx, accessToken, realm, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteIdentityProvider provides a mock function with given fields: ctx, token, realm, alias
func (_m *GoCloak) DeleteIdentityProvider(ctx context.Context, token string, realm string, alias string) error {
	ret := _m.Called(ctx, token, realm, alias)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, alias)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteIdentityProviderMapper provides a mock function with given fields: ctx, token, realm, alias, mapperID
func (_m *GoCloak) DeleteIdentityProviderMapper(ctx context.Context, token string, realm string, alias string, mapperID string) error {
	ret := _m.Called(ctx, token, realm, alias, mapperID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, alias, mapperID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePermission provides a mock function with given fields: ctx, token, realm, idOfClient, permissionID
func (_m *GoCloak) DeletePermission(ctx context.Context, token string, realm string, idOfClient string, permissionID string) error {
	ret := _m.Called(ctx, token, realm, idOfClient, permissionID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, permissionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePolicy provides a mock function with given fields: ctx, token, realm, idOfClient, policyID
func (_m *GoCloak) DeletePolicy(ctx context.Context, token string, realm string, idOfClient string, policyID string) error {
	ret := _m.Called(ctx, token, realm, idOfClient, policyID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealm provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) DeleteRealm(ctx context.Context, token string, realm string) error {
	ret := _m.Called(ctx, token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealmRole provides a mock function with given fields: ctx, token, realm, roleName
func (_m *GoCloak) DeleteRealmRole(ctx context.Context, token string, realm string, roleName string) error {
	ret := _m.Called(ctx, token, realm, roleName)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealmRoleComposite provides a mock function with given fields: ctx, token, realm, roleName, roles
func (_m *GoCloak) DeleteRealmRoleComposite(ctx context.Context, token string, realm string, roleName string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, roleName, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, roleName, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealmRoleFromGroup provides a mock function with given fields: ctx, token, realm, groupID, roles
func (_m *GoCloak) DeleteRealmRoleFromGroup(ctx context.Context, token string, realm string, groupID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, groupID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, groupID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealmRoleFromUser provides a mock function with given fields: ctx, token, realm, userID, roles
func (_m *GoCloak) DeleteRealmRoleFromUser(ctx context.Context, token string, realm string, userID string, roles []gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, userID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, userID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteResource provides a mock function with given fields: ctx, token, realm, idOfClient, resourceID
func (_m *GoCloak) DeleteResource(ctx context.Context, token string, realm string, idOfClient string, resourceID string) error {
	ret := _m.Called(ctx, token, realm, idOfClient, resourceID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, resourceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteResourceClient provides a mock function with given fields: ctx, token, realm, resourceID
func (_m *GoCloak) DeleteResourceClient(ctx context.Context, token string, realm string, resourceID string) error {
	ret := _m.Called(ctx, token, realm, resourceID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, resourceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, token, realm, permissionID
func (_m *GoCloak) DeleteResourcePolicy(ctx context.Context, token string, realm string, permissionID string) error {
	ret := _m.Called(ctx, token, realm, permissionID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, permissionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteScope provides a mock function with given fields: ctx, token, realm, idOfClient, scopeID
func (_m *GoCloak) DeleteScope(ctx context.Context, token string, realm string, idOfClient string, scopeID string) error {
	ret := _m.Called(ctx, token, realm, idOfClient, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUser provides a mock function with given fields: ctx, accessToken, realm, userID
func (_m *GoCloak) DeleteUser(ctx context.Context, accessToken string, realm string, userID string) error {
	ret := _m.Called(ctx, accessToken, realm, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUserFederatedIdentity provides a mock function with given fields: ctx, token, realm, userID, providerID
func (_m *GoCloak) DeleteUserFederatedIdentity(ctx context.Context, token string, realm string, userID string, providerID string) error {
	ret := _m.Called(ctx, token, realm, userID, providerID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, userID, providerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUserFromGroup provides a mock function with given fields: ctx, token, realm, userID, groupID
func (_m *GoCloak) DeleteUserFromGroup(ctx context.Context, token string, realm string, userID string, groupID string) error {
	ret := _m.Called(ctx, token, realm, userID, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, userID, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUserPermission provides a mock function with given fields: ctx, token, realm, ticketID
func (_m *GoCloak) DeleteUserPermission(ctx context.Context, token string, realm string, ticketID string) error {
	ret := _m.Called(ctx, token, realm, ticketID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, ticketID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DisableAllCredentialsByType provides a mock function with given fields: ctx, token, realm, userID, types
func (_m *GoCloak) DisableAllCredentialsByType(ctx context.Context, token string, realm string, userID string, types []string) error {
	ret := _m.Called(ctx, token, realm, userID, types)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []string) error); ok {
		r0 = rf(ctx, token, realm, userID, types)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteActionsEmail provides a mock function with given fields: ctx, token, realm, params
func (_m *GoCloak) ExecuteActionsEmail(ctx context.Context, token string, realm string, params gocloak.ExecuteActionsEmail) error {
	ret := _m.Called(ctx, token, realm, params)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.ExecuteActionsEmail) error); ok {
		r0 = rf(ctx, token, realm, params)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExportIDPPublicBrokerConfig provides a mock function with given fields: ctx, token, realm, alias
func (_m *GoCloak) ExportIDPPublicBrokerConfig(ctx context.Context, token string, realm string, alias string) (*string, error) {
	ret := _m.Called(ctx, token, realm, alias)

	var r0 *string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *string); ok {
		r0 = rf(ctx, token, realm, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, alias)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAdapterConfiguration provides a mock function with given fields: ctx, accessToken, realm, clientID
func (_m *GoCloak) GetAdapterConfiguration(ctx context.Context, accessToken string, realm string, clientID string) (*gocloak.AdapterConfiguration, error) {
	ret := _m.Called(ctx, accessToken, realm, clientID)

	var r0 *gocloak.AdapterConfiguration
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.AdapterConfiguration); ok {
		r0 = rf(ctx, accessToken, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.AdapterConfiguration)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAuthenticationExecutions provides a mock function with given fields: ctx, token, realm, flow
func (_m *GoCloak) GetAuthenticationExecutions(ctx context.Context, token string, realm string, flow string) ([]*gocloak.ModifyAuthenticationExecutionRepresentation, error) {
	ret := _m.Called(ctx, token, realm, flow)

	var r0 []*gocloak.ModifyAuthenticationExecutionRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.ModifyAuthenticationExecutionRepresentation); ok {
		r0 = rf(ctx, token, realm, flow)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ModifyAuthenticationExecutionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, flow)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAuthenticationFlows provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) GetAuthenticationFlows(ctx context.Context, token string, realm string) ([]*gocloak.AuthenticationFlowRepresentation, error) {
	ret := _m.Called(ctx, token, realm)

	var r0 []*gocloak.AuthenticationFlowRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*gocloak.AuthenticationFlowRepresentation); ok {
		r0 = rf(ctx, token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.AuthenticationFlowRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAuthorizationPolicyAssociatedPolicies provides a mock function with given fields: ctx, token, realm, idOfClient, policyID
func (_m *GoCloak) GetAuthorizationPolicyAssociatedPolicies(ctx context.Context, token string, realm string, idOfClient string, policyID string) ([]*gocloak.PolicyRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, policyID)

	var r0 []*gocloak.PolicyRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.PolicyRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAuthorizationPolicyResources provides a mock function with given fields: ctx, token, realm, idOfClient, policyID
func (_m *GoCloak) GetAuthorizationPolicyResources(ctx context.Context, token string, realm string, idOfClient string, policyID string) ([]*gocloak.PolicyResourceRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, policyID)

	var r0 []*gocloak.PolicyResourceRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.PolicyResourceRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PolicyResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAuthorizationPolicyScopes provides a mock function with given fields: ctx, token, realm, idOfClient, policyID
func (_m *GoCloak) GetAuthorizationPolicyScopes(ctx context.Context, token string, realm string, idOfClient string, policyID string) ([]*gocloak.PolicyScopeRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, policyID)

	var r0 []*gocloak.PolicyScopeRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.PolicyScopeRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PolicyScopeRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAvailableClientRolesByGroupID provides a mock function with given fields: ctx, token, realm, idOfClient, groupID
func (_m *GoCloak) GetAvailableClientRolesByGroupID(ctx context.Context, token string, realm string, idOfClient string, groupID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, groupID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAvailableClientRolesByUserID provides a mock function with given fields: ctx, token, realm, idOfClient, userID
func (_m *GoCloak) GetAvailableClientRolesByUserID(ctx context.Context, token string, realm string, idOfClient string, userID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, userID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAvailableRealmRolesByGroupID provides a mock function with given fields: ctx, token, realm, groupID
func (_m *GoCloak) GetAvailableRealmRolesByGroupID(ctx context.Context, token string, realm string, groupID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, groupID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAvailableRealmRolesByUserID provides a mock function with given fields: ctx, token, realm, userID
func (_m *GoCloak) GetAvailableRealmRolesByUserID(ctx context.Context, token string, realm string, userID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, userID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCerts provides a mock function with given fields: ctx, realm
func (_m *GoCloak) GetCerts(ctx context.Context, realm string) (*gocloak.CertResponse, error) {
	ret := _m.Called(ctx, realm)

	var r0 *gocloak.CertResponse
	if rf, ok := ret.Get(0).(func(context.Context, string) *gocloak.CertResponse); ok {
		r0 = rf(ctx, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.CertResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClient provides a mock function with given fields: ctx, accessToken, realm, idOfClient
func (_m *GoCloak) GetClient(ctx context.Context, accessToken string, realm string, idOfClient string) (*gocloak.Client, error) {
	ret := _m.Called(ctx, accessToken, realm, idOfClient)

	var r0 *gocloak.Client
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.Client); ok {
		r0 = rf(ctx, accessToken, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientOfflineSessions provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) GetClientOfflineSessions(ctx context.Context, token string, realm string, idOfClient string) ([]*gocloak.UserSessionRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 []*gocloak.UserSessionRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.UserSessionRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.UserSessionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRepresentation provides a mock function with given fields: ctx, accessToken, realm, clientID
func (_m *GoCloak) GetClientRepresentation(ctx context.Context, accessToken string, realm string, clientID string) (*gocloak.Client, error) {
	ret := _m.Called(ctx, accessToken, realm, clientID)

	var r0 *gocloak.Client
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.Client); ok {
		r0 = rf(ctx, accessToken, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRole provides a mock function with given fields: ctx, token, realm, idOfClient, roleName
func (_m *GoCloak) GetClientRole(ctx context.Context, token string, realm string, idOfClient string, roleName string) (*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, roleName)

	var r0 *gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRoleByID provides a mock function with given fields: ctx, accessToken, realm, roleID
func (_m *GoCloak) GetClientRoleByID(ctx context.Context, accessToken string, realm string, roleID string) (*gocloak.Role, error) {
	ret := _m.Called(ctx, accessToken, realm, roleID)

	var r0 *gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.Role); ok {
		r0 = rf(ctx, accessToken, realm, roleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, roleID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRoles provides a mock function with given fields: ctx, accessToken, realm, idOfClient, params
func (_m *GoCloak) GetClientRoles(ctx context.Context, accessToken string, realm string, idOfClient string, params gocloak.GetRoleParams) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, accessToken, realm, idOfClient, params)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.GetRoleParams) []*gocloak.Role); ok {
		r0 = rf(ctx, accessToken, realm, idOfClient, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.GetRoleParams) error); ok {
		r1 = rf(ctx, accessToken, realm, idOfClient, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRolesByGroupID provides a mock function with given fields: ctx, token, realm, idOfClient, groupID
func (_m *GoCloak) GetClientRolesByGroupID(ctx context.Context, token string, realm string, idOfClient string, groupID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, groupID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRolesByUserID provides a mock function with given fields: ctx, token, realm, idOfClient, userID
func (_m *GoCloak) GetClientRolesByUserID(ctx context.Context, token string, realm string, idOfClient string, userID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, userID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScope provides a mock function with given fields: ctx, token, realm, scopeID
func (_m *GoCloak) GetClientScope(ctx context.Context, token string, realm string, scopeID string) (*gocloak.ClientScope, error) {
	ret := _m.Called(ctx, token, realm, scopeID)

	var r0 *gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.ClientScope); ok {
		r0 = rf(ctx, token, realm, scopeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, scopeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopeMappings provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) GetClientScopeMappings(ctx context.Context, token string, realm string, idOfClient string) (*gocloak.MappingsRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 *gocloak.MappingsRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.MappingsRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.MappingsRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopeMappingsClientRoles provides a mock function with given fields: ctx, token, realm, idOfClient, idOfSelectedClient
func (_m *GoCloak) GetClientScopeMappingsClientRoles(ctx context.Context, token string, realm string, idOfClient string, idOfSelectedClient string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, idOfSelectedClient)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, idOfSelectedClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, idOfSelectedClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopeMappingsClientRolesAvailable provides a mock function with given fields: ctx, token, realm, idOfClient, idOfSelectedClient
func (_m *GoCloak) GetClientScopeMappingsClientRolesAvailable(ctx context.Context, token string, realm string, idOfClient string, idOfSelectedClient string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, idOfSelectedClient)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, idOfSelectedClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, idOfSelectedClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopeMappingsRealmRoles provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) GetClientScopeMappingsRealmRoles(ctx context.Context, token string, realm string, idOfClient string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopeMappingsRealmRolesAvailable provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) GetClientScopeMappingsRealmRolesAvailable(ctx context.Context, token string, realm string, idOfClient string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopeProtocolMapper provides a mock function with given fields: ctx, token, realm, scopeID, protocolMapperID
func (_m *GoCloak) GetClientScopeProtocolMapper(ctx context.Context, token string, realm string, scopeID string, protocolMapperID string) (*gocloak.ProtocolMappers, error) {
	ret := _m.Called(ctx, token, realm, scopeID, protocolMapperID)

	var r0 *gocloak.ProtocolMappers
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *gocloak.ProtocolMappers); ok {
		r0 = rf(ctx, token, realm, scopeID, protocolMapperID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ProtocolMappers)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, scopeID, protocolMapperID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopeProtocolMappers provides a mock function with given fields: ctx, token, realm, scopeID
func (_m *GoCloak) GetClientScopeProtocolMappers(ctx context.Context, token string, realm string, scopeID string) ([]*gocloak.ProtocolMappers, error) {
	ret := _m.Called(ctx, token, realm, scopeID)

	var r0 []*gocloak.ProtocolMappers
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.ProtocolMappers); ok {
		r0 = rf(ctx, token, realm, scopeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ProtocolMappers)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, scopeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopes provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) GetClientScopes(ctx context.Context, token string, realm string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(ctx, token, realm)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*gocloak.ClientScope); ok {
		r0 = rf(ctx, token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopesScopeMappingsClientRoles provides a mock function with given fields: ctx, token, realm, idOfClientScope, idOfClient
func (_m *GoCloak) GetClientScopesScopeMappingsClientRoles(ctx context.Context, token string, realm string, idOfClientScope string, idOfClient string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClientScope, idOfClient)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClientScope, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClientScope, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopesScopeMappingsClientRolesAvailable provides a mock function with given fields: ctx, token, realm, idOfClientScope, idOfClient
func (_m *GoCloak) GetClientScopesScopeMappingsClientRolesAvailable(ctx context.Context, token string, realm string, idOfClientScope string, idOfClient string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClientScope, idOfClient)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClientScope, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClientScope, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopesScopeMappingsRealmRoles provides a mock function with given fields: ctx, token, realm, idOfClientScope
func (_m *GoCloak) GetClientScopesScopeMappingsRealmRoles(ctx context.Context, token string, realm string, idOfClientScope string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClientScope)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClientScope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClientScope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopesScopeMappingsRealmRolesAvailable provides a mock function with given fields: ctx, token, realm, idOfClientScope
func (_m *GoCloak) GetClientScopesScopeMappingsRealmRolesAvailable(ctx context.Context, token string, realm string, idOfClientScope string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClientScope)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClientScope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClientScope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientSecret provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) GetClientSecret(ctx context.Context, token string, realm string, idOfClient string) (*gocloak.CredentialRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 *gocloak.CredentialRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.CredentialRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.CredentialRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientServiceAccount provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) GetClientServiceAccount(ctx context.Context, token string, realm string, idOfClient string) (*gocloak.User, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 *gocloak.User
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.User); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientUserSessions provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) GetClientUserSessions(ctx context.Context, token string, realm string, idOfClient string) ([]*gocloak.UserSessionRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 []*gocloak.UserSessionRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.UserSessionRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.UserSessionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClients provides a mock function with given fields: ctx, accessToken, realm, params
func (_m *GoCloak) GetClients(ctx context.Context, accessToken string, realm string, params gocloak.GetClientsParams) ([]*gocloak.Client, error) {
	ret := _m.Called(ctx, accessToken, realm, params)

	var r0 []*gocloak.Client
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetClientsParams) []*gocloak.Client); ok {
		r0 = rf(ctx, accessToken, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetClientsParams) error); ok {
		r1 = rf(ctx, accessToken, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientsDefaultScopes provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) GetClientsDefaultScopes(ctx context.Context, token string, realm string, idOfClient string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.ClientScope); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientsOptionalScopes provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) GetClientsOptionalScopes(ctx context.Context, token string, realm string, idOfClient string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.ClientScope); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetComponents provides a mock function with given fields: ctx, accessToken, realm
func (_m *GoCloak) GetComponents(ctx context.Context, accessToken string, realm string) ([]*gocloak.Component, error) {
	ret := _m.Called(ctx, accessToken, realm)

	var r0 []*gocloak.Component
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*gocloak.Component); ok {
		r0 = rf(ctx, accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Component)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeClientRolesByGroupID provides a mock function with given fields: ctx, token, realm, idOfClient, groupID
func (_m *GoCloak) GetCompositeClientRolesByGroupID(ctx context.Context, token string, realm string, idOfClient string, groupID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, groupID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeClientRolesByRoleID provides a mock function with given fields: ctx, token, realm, idOfClient, roleID
func (_m *GoCloak) GetCompositeClientRolesByRoleID(ctx context.Context, token string, realm string, idOfClient string, roleID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, roleID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, roleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, roleID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeClientRolesByUserID provides a mock function with given fields: ctx, token, realm, idOfClient, userID
func (_m *GoCloak) GetCompositeClientRolesByUserID(ctx context.Context, token string, realm string, idOfClient string, userID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, userID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, idOfClient, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeRealmRoles provides a mock function with given fields: ctx, token, realm, roleName
func (_m *GoCloak) GetCompositeRealmRoles(ctx context.Context, token string, realm string, roleName string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, roleName)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeRealmRolesByGroupID provides a mock function with given fields: ctx, token, realm, groupID
func (_m *GoCloak) GetCompositeRealmRolesByGroupID(ctx context.Context, token string, realm string, groupID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, groupID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeRealmRolesByRoleID provides a mock function with given fields: ctx, token, realm, roleID
func (_m *GoCloak) GetCompositeRealmRolesByRoleID(ctx context.Context, token string, realm string, roleID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, roleID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, roleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, roleID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeRealmRolesByUserID provides a mock function with given fields: ctx, token, realm, userID
func (_m *GoCloak) GetCompositeRealmRolesByUserID(ctx context.Context, token string, realm string, userID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, userID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, token, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfiguredUserStorageCredentialTypes provides a mock function with given fields: ctx, token, realm, userID
func (_m *GoCloak) GetConfiguredUserStorageCredentialTypes(ctx context.Context, token string, realm string, userID string) ([]string, error) {
	ret := _m.Called(ctx, token, realm, userID)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []string); ok {
		r0 = rf(ctx, token, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCredentialRegistrators provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) GetCredentialRegistrators(ctx context.Context, token string, realm string) ([]string, error) {
	ret := _m.Called(ctx, token, realm)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []string); ok {
		r0 = rf(ctx, token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCredentials provides a mock function with given fields: ctx, token, realm, UserID
func (_m *GoCloak) GetCredentials(ctx context.Context, token string, realm string, UserID string) ([]*gocloak.CredentialRepresentation, error) {
	ret := _m.Called(ctx, token, realm, UserID)

	var r0 []*gocloak.CredentialRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.CredentialRepresentation); ok {
		r0 = rf(ctx, token, realm, UserID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.CredentialRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, UserID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultDefaultClientScopes provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) GetDefaultDefaultClientScopes(ctx context.Context, token string, realm string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(ctx, token, realm)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*gocloak.ClientScope); ok {
		r0 = rf(ctx, token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultGroups provides a mock function with given fields: ctx, accessToken, realm
func (_m *GoCloak) GetDefaultGroups(ctx context.Context, accessToken string, realm string) ([]*gocloak.Group, error) {
	ret := _m.Called(ctx, accessToken, realm)

	var r0 []*gocloak.Group
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*gocloak.Group); ok {
		r0 = rf(ctx, accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultOptionalClientScopes provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) GetDefaultOptionalClientScopes(ctx context.Context, token string, realm string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(ctx, token, realm)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*gocloak.ClientScope); ok {
		r0 = rf(ctx, token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDependentPermissions provides a mock function with given fields: ctx, token, realm, idOfClient, policyID
func (_m *GoCloak) GetDependentPermissions(ctx context.Context, token string, realm string, idOfClient string, policyID string) ([]*gocloak.PermissionRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, policyID)

	var r0 []*gocloak.PermissionRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.PermissionRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PermissionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvents provides a mock function with given fields: ctx, token, realm, params
func (_m *GoCloak) GetEvents(ctx context.Context, token string, realm string, params gocloak.GetEventsParams) ([]*gocloak.EventRepresentation, error) {
	ret := _m.Called(ctx, token, realm, params)

	var r0 []*gocloak.EventRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetEventsParams) []*gocloak.EventRepresentation); ok {
		r0 = rf(ctx, token, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.EventRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetEventsParams) error); ok {
		r1 = rf(ctx, token, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroup provides a mock function with given fields: ctx, accessToken, realm, groupID
func (_m *GoCloak) GetGroup(ctx context.Context, accessToken string, realm string, groupID string) (*gocloak.Group, error) {
	ret := _m.Called(ctx, accessToken, realm, groupID)

	var r0 *gocloak.Group
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.Group); ok {
		r0 = rf(ctx, accessToken, realm, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupMembers provides a mock function with given fields: ctx, accessToken, realm, groupID, params
func (_m *GoCloak) GetGroupMembers(ctx context.Context, accessToken string, realm string, groupID string, params gocloak.GetGroupsParams) ([]*gocloak.User, error) {
	ret := _m.Called(ctx, accessToken, realm, groupID, params)

	var r0 []*gocloak.User
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.GetGroupsParams) []*gocloak.User); ok {
		r0 = rf(ctx, accessToken, realm, groupID, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.GetGroupsParams) error); ok {
		r1 = rf(ctx, accessToken, realm, groupID, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroups provides a mock function with given fields: ctx, accessToken, realm, params
func (_m *GoCloak) GetGroups(ctx context.Context, accessToken string, realm string, params gocloak.GetGroupsParams) ([]*gocloak.Group, error) {
	ret := _m.Called(ctx, accessToken, realm, params)

	var r0 []*gocloak.Group
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetGroupsParams) []*gocloak.Group); ok {
		r0 = rf(ctx, accessToken, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetGroupsParams) error); ok {
		r1 = rf(ctx, accessToken, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupsByRole provides a mock function with given fields: ctx, accessToken, realm, roleName
func (_m *GoCloak) GetGroupsByRole(ctx context.Context, accessToken string, realm string, roleName string) ([]*gocloak.Group, error) {
	ret := _m.Called(ctx, accessToken, realm, roleName)

	var r0 []*gocloak.Group
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Group); ok {
		r0 = rf(ctx, accessToken, realm, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupsCount provides a mock function with given fields: ctx, token, realm, params
func (_m *GoCloak) GetGroupsCount(ctx context.Context, token string, realm string, params gocloak.GetGroupsParams) (int, error) {
	ret := _m.Called(ctx, token, realm, params)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetGroupsParams) int); ok {
		r0 = rf(ctx, token, realm, params)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetGroupsParams) error); ok {
		r1 = rf(ctx, token, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityProvider provides a mock function with given fields: ctx, token, realm, alias
func (_m *GoCloak) GetIdentityProvider(ctx context.Context, token string, realm string, alias string) (*gocloak.IdentityProviderRepresentation, error) {
	ret := _m.Called(ctx, token, realm, alias)

	var r0 *gocloak.IdentityProviderRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.IdentityProviderRepresentation); ok {
		r0 = rf(ctx, token, realm, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.IdentityProviderRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, alias)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityProviderMapperByID provides a mock function with given fields: ctx, token, realm, alias, mapperID
func (_m *GoCloak) GetIdentityProviderMapperByID(ctx context.Context, token string, realm string, alias string, mapperID string) (*gocloak.IdentityProviderMapper, error) {
	ret := _m.Called(ctx, token, realm, alias, mapperID)

	var r0 *gocloak.IdentityProviderMapper
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *gocloak.IdentityProviderMapper); ok {
		r0 = rf(ctx, token, realm, alias, mapperID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.IdentityProviderMapper)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, alias, mapperID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityProviderMappers provides a mock function with given fields: ctx, token, realm, alias
func (_m *GoCloak) GetIdentityProviderMappers(ctx context.Context, token string, realm string, alias string) ([]*gocloak.IdentityProviderMapper, error) {
	ret := _m.Called(ctx, token, realm, alias)

	var r0 []*gocloak.IdentityProviderMapper
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.IdentityProviderMapper); ok {
		r0 = rf(ctx, token, realm, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.IdentityProviderMapper)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, alias)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityProviders provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) GetIdentityProviders(ctx context.Context, token string, realm string) ([]*gocloak.IdentityProviderRepresentation, error) {
	ret := _m.Called(ctx, token, realm)

	var r0 []*gocloak.IdentityProviderRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*gocloak.IdentityProviderRepresentation); ok {
		r0 = rf(ctx, token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.IdentityProviderRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIssuer provides a mock function with given fields: ctx, realm
func (_m *GoCloak) GetIssuer(ctx context.Context, realm string) (*gocloak.IssuerResponse, error) {
	ret := _m.Called(ctx, realm)

	var r0 *gocloak.IssuerResponse
	if rf, ok := ret.Get(0).(func(context.Context, string) *gocloak.IssuerResponse); ok {
		r0 = rf(ctx, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.IssuerResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeyStoreConfig provides a mock function with given fields: ctx, accessToken, realm
func (_m *GoCloak) GetKeyStoreConfig(ctx context.Context, accessToken string, realm string) (*gocloak.KeyStoreConfig, error) {
	ret := _m.Called(ctx, accessToken, realm)

	var r0 *gocloak.KeyStoreConfig
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *gocloak.KeyStoreConfig); ok {
		r0 = rf(ctx, accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.KeyStoreConfig)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermission provides a mock function with given fields: ctx, token, realm, idOfClient, permissionID
func (_m *GoCloak) GetPermission(ctx context.Context, token string, realm string, idOfClient string, permissionID string) (*gocloak.PermissionRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, permissionID)

	var r0 *gocloak.PermissionRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *gocloak.PermissionRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, permissionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PermissionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, permissionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermissionResources provides a mock function with given fields: ctx, token, realm, idOfClient, permissionID
func (_m *GoCloak) GetPermissionResources(ctx context.Context, token string, realm string, idOfClient string, permissionID string) ([]*gocloak.PermissionResource, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, permissionID)

	var r0 []*gocloak.PermissionResource
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.PermissionResource); ok {
		r0 = rf(ctx, token, realm, idOfClient, permissionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PermissionResource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, permissionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermissionScopes provides a mock function with given fields: ctx, token, realm, idOfClient, permissionID
func (_m *GoCloak) GetPermissionScopes(ctx context.Context, token string, realm string, idOfClient string, permissionID string) ([]*gocloak.PermissionScope, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, permissionID)

	var r0 []*gocloak.PermissionScope
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.PermissionScope); ok {
		r0 = rf(ctx, token, realm, idOfClient, permissionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PermissionScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, permissionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermissions provides a mock function with given fields: ctx, token, realm, idOfClient, params
func (_m *GoCloak) GetPermissions(ctx context.Context, token string, realm string, idOfClient string, params gocloak.GetPermissionParams) ([]*gocloak.PermissionRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, params)

	var r0 []*gocloak.PermissionRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.GetPermissionParams) []*gocloak.PermissionRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PermissionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.GetPermissionParams) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPolicies provides a mock function with given fields: ctx, token, realm, idOfClient, params
func (_m *GoCloak) GetPolicies(ctx context.Context, token string, realm string, idOfClient string, params gocloak.GetPolicyParams) ([]*gocloak.PolicyRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, params)

	var r0 []*gocloak.PolicyRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.GetPolicyParams) []*gocloak.PolicyRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.GetPolicyParams) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPolicy provides a mock function with given fields: ctx, token, realm, idOfClient, policyID
func (_m *GoCloak) GetPolicy(ctx context.Context, token string, realm string, idOfClient string, policyID string) (*gocloak.PolicyRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, policyID)

	var r0 *gocloak.PolicyRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *gocloak.PolicyRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, policyID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRawUserInfo provides a mock function with given fields: ctx, accessToken, realm
func (_m *GoCloak) GetRawUserInfo(ctx context.Context, accessToken string, realm string) (map[string]interface{}, error) {
	ret := _m.Called(ctx, accessToken, realm)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) map[string]interface{}); ok {
		r0 = rf(ctx, accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealm provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) GetRealm(ctx context.Context, token string, realm string) (*gocloak.RealmRepresentation, error) {
	ret := _m.Called(ctx, token, realm)

	var r0 *gocloak.RealmRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *gocloak.RealmRepresentation); ok {
		r0 = rf(ctx, token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.RealmRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealmRole provides a mock function with given fields: ctx, token, realm, roleName
func (_m *GoCloak) GetRealmRole(ctx context.Context, token string, realm string, roleName string) (*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, roleName)

	var r0 *gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.Role); ok {
		r0 = rf(ctx, token, realm, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealmRoleByID provides a mock function with given fields: ctx, token, realm, roleID
func (_m *GoCloak) GetRealmRoleByID(ctx context.Context, token string, realm string, roleID string) (*gocloak.Role, error) {
	ret := _m.Called(ctx, token, realm, roleID)

	var r0 *gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.Role); ok {
		r0 = rf(ctx, token, realm, roleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, roleID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealmRoles provides a mock function with given fields: ctx, accessToken, realm, params
func (_m *GoCloak) GetRealmRoles(ctx context.Context, accessToken string, realm string, params gocloak.GetRoleParams) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, accessToken, realm, params)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetRoleParams) []*gocloak.Role); ok {
		r0 = rf(ctx, accessToken, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetRoleParams) error); ok {
		r1 = rf(ctx, accessToken, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealmRolesByGroupID provides a mock function with given fields: ctx, accessToken, realm, groupID
func (_m *GoCloak) GetRealmRolesByGroupID(ctx context.Context, accessToken string, realm string, groupID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, accessToken, realm, groupID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, accessToken, realm, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealmRolesByUserID provides a mock function with given fields: ctx, accessToken, realm, userID
func (_m *GoCloak) GetRealmRolesByUserID(ctx context.Context, accessToken string, realm string, userID string) ([]*gocloak.Role, error) {
	ret := _m.Called(ctx, accessToken, realm, userID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.Role); ok {
		r0 = rf(ctx, accessToken, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealms provides a mock function with given fields: ctx, token
func (_m *GoCloak) GetRealms(ctx context.Context, token string) ([]*gocloak.RealmRepresentation, error) {
	ret := _m.Called(ctx, token)

	var r0 []*gocloak.RealmRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string) []*gocloak.RealmRepresentation); ok {
		r0 = rf(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.RealmRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRequestingPartyPermissionDecision provides a mock function with given fields: ctx, token, realm, options
func (_m *GoCloak) GetRequestingPartyPermissionDecision(ctx context.Context, token string, realm string, options gocloak.RequestingPartyTokenOptions) (*gocloak.RequestingPartyPermissionDecision, error) {
	ret := _m.Called(ctx, token, realm, options)

	var r0 *gocloak.RequestingPartyPermissionDecision
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.RequestingPartyTokenOptions) *gocloak.RequestingPartyPermissionDecision); ok {
		r0 = rf(ctx, token, realm, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.RequestingPartyPermissionDecision)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.RequestingPartyTokenOptions) error); ok {
		r1 = rf(ctx, token, realm, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRequestingPartyPermissions provides a mock function with given fields: ctx, token, realm, options
func (_m *GoCloak) GetRequestingPartyPermissions(ctx context.Context, token string, realm string, options gocloak.RequestingPartyTokenOptions) (*[]gocloak.RequestingPartyPermission, error) {
	ret := _m.Called(ctx, token, realm, options)

	var r0 *[]gocloak.RequestingPartyPermission
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.RequestingPartyTokenOptions) *[]gocloak.RequestingPartyPermission); ok {
		r0 = rf(ctx, token, realm, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]gocloak.RequestingPartyPermission)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.RequestingPartyTokenOptions) error); ok {
		r1 = rf(ctx, token, realm, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRequestingPartyToken provides a mock function with given fields: ctx, token, realm, options
func (_m *GoCloak) GetRequestingPartyToken(ctx context.Context, token string, realm string, options gocloak.RequestingPartyTokenOptions) (*gocloak.JWT, error) {
	ret := _m.Called(ctx, token, realm, options)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.RequestingPartyTokenOptions) *gocloak.JWT); ok {
		r0 = rf(ctx, token, realm, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.RequestingPartyTokenOptions) error); ok {
		r1 = rf(ctx, token, realm, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResource provides a mock function with given fields: ctx, token, realm, idOfClient, resourceID
func (_m *GoCloak) GetResource(ctx context.Context, token string, realm string, idOfClient string, resourceID string) (*gocloak.ResourceRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, resourceID)

	var r0 *gocloak.ResourceRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *gocloak.ResourceRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, resourceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, resourceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourceClient provides a mock function with given fields: ctx, token, realm, resourceID
func (_m *GoCloak) GetResourceClient(ctx context.Context, token string, realm string, resourceID string) (*gocloak.ResourceRepresentation, error) {
	ret := _m.Called(ctx, token, realm, resourceID)

	var r0 *gocloak.ResourceRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.ResourceRepresentation); ok {
		r0 = rf(ctx, token, realm, resourceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, resourceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourcePolicies provides a mock function with given fields: ctx, token, realm, params
func (_m *GoCloak) GetResourcePolicies(ctx context.Context, token string, realm string, params gocloak.GetResourcePoliciesParams) ([]*gocloak.ResourcePolicyRepresentation, error) {
	ret := _m.Called(ctx, token, realm, params)

	var r0 []*gocloak.ResourcePolicyRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetResourcePoliciesParams) []*gocloak.ResourcePolicyRepresentation); ok {
		r0 = rf(ctx, token, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ResourcePolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetResourcePoliciesParams) error); ok {
		r1 = rf(ctx, token, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourcePolicy provides a mock function with given fields: ctx, token, realm, permissionID
func (_m *GoCloak) GetResourcePolicy(ctx context.Context, token string, realm string, permissionID string) (*gocloak.ResourcePolicyRepresentation, error) {
	ret := _m.Called(ctx, token, realm, permissionID)

	var r0 *gocloak.ResourcePolicyRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.ResourcePolicyRepresentation); ok {
		r0 = rf(ctx, token, realm, permissionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ResourcePolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, permissionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResources provides a mock function with given fields: ctx, token, realm, idOfClient, params
func (_m *GoCloak) GetResources(ctx context.Context, token string, realm string, idOfClient string, params gocloak.GetResourceParams) ([]*gocloak.ResourceRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, params)

	var r0 []*gocloak.ResourceRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.GetResourceParams) []*gocloak.ResourceRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.GetResourceParams) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourcesClient provides a mock function with given fields: ctx, token, realm, params
func (_m *GoCloak) GetResourcesClient(ctx context.Context, token string, realm string, params gocloak.GetResourceParams) ([]*gocloak.ResourceRepresentation, error) {
	ret := _m.Called(ctx, token, realm, params)

	var r0 []*gocloak.ResourceRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetResourceParams) []*gocloak.ResourceRepresentation); ok {
		r0 = rf(ctx, token, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetResourceParams) error); ok {
		r1 = rf(ctx, token, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRoleMappingByGroupID provides a mock function with given fields: ctx, accessToken, realm, groupID
func (_m *GoCloak) GetRoleMappingByGroupID(ctx context.Context, accessToken string, realm string, groupID string) (*gocloak.MappingsRepresentation, error) {
	ret := _m.Called(ctx, accessToken, realm, groupID)

	var r0 *gocloak.MappingsRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.MappingsRepresentation); ok {
		r0 = rf(ctx, accessToken, realm, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.MappingsRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRoleMappingByUserID provides a mock function with given fields: ctx, accessToken, realm, userID
func (_m *GoCloak) GetRoleMappingByUserID(ctx context.Context, accessToken string, realm string, userID string) (*gocloak.MappingsRepresentation, error) {
	ret := _m.Called(ctx, accessToken, realm, userID)

	var r0 *gocloak.MappingsRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.MappingsRepresentation); ok {
		r0 = rf(ctx, accessToken, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.MappingsRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetScope provides a mock function with given fields: ctx, token, realm, idOfClient, scopeID
func (_m *GoCloak) GetScope(ctx context.Context, token string, realm string, idOfClient string, scopeID string) (*gocloak.ScopeRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, scopeID)

	var r0 *gocloak.ScopeRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *gocloak.ScopeRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, scopeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ScopeRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, scopeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetScopes provides a mock function with given fields: ctx, token, realm, idOfClient, params
func (_m *GoCloak) GetScopes(ctx context.Context, token string, realm string, idOfClient string, params gocloak.GetScopeParams) ([]*gocloak.ScopeRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, params)

	var r0 []*gocloak.ScopeRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.GetScopeParams) []*gocloak.ScopeRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ScopeRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.GetScopeParams) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServerInfo provides a mock function with given fields: ctx, accessToken
func (_m *GoCloak) GetServerInfo(ctx context.Context, accessToken string) (*gocloak.ServerInfoRepesentation, error) {
	ret := _m.Called(ctx, accessToken)

	var r0 *gocloak.ServerInfoRepesentation
	if rf, ok := ret.Get(0).(func(context.Context, string) *gocloak.ServerInfoRepesentation); ok {
		r0 = rf(ctx, accessToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ServerInfoRepesentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accessToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetToken provides a mock function with given fields: ctx, realm, options
func (_m *GoCloak) GetToken(ctx context.Context, realm string, options gocloak.TokenOptions) (*gocloak.JWT, error) {
	ret := _m.Called(ctx, realm, options)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(context.Context, string, gocloak.TokenOptions) *gocloak.JWT); ok {
		r0 = rf(ctx, realm, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, gocloak.TokenOptions) error); ok {
		r1 = rf(ctx, realm, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserByID provides a mock function with given fields: ctx, accessToken, realm, userID
func (_m *GoCloak) GetUserByID(ctx context.Context, accessToken string, realm string, userID string) (*gocloak.User, error) {
	ret := _m.Called(ctx, accessToken, realm, userID)

	var r0 *gocloak.User
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.User); ok {
		r0 = rf(ctx, accessToken, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserCount provides a mock function with given fields: ctx, accessToken, realm, params
func (_m *GoCloak) GetUserCount(ctx context.Context, accessToken string, realm string, params gocloak.GetUsersParams) (int, error) {
	ret := _m.Called(ctx, accessToken, realm, params)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetUsersParams) int); ok {
		r0 = rf(ctx, accessToken, realm, params)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetUsersParams) error); ok {
		r1 = rf(ctx, accessToken, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserFederatedIdentities provides a mock function with given fields: ctx, token, realm, userID
func (_m *GoCloak) GetUserFederatedIdentities(ctx context.Context, token string, realm string, userID string) ([]*gocloak.FederatedIdentityRepresentation, error) {
	ret := _m.Called(ctx, token, realm, userID)

	var r0 []*gocloak.FederatedIdentityRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.FederatedIdentityRepresentation); ok {
		r0 = rf(ctx, token, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.FederatedIdentityRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserGroups provides a mock function with given fields: ctx, accessToken, realm, userID, params
func (_m *GoCloak) GetUserGroups(ctx context.Context, accessToken string, realm string, userID string, params gocloak.GetGroupsParams) ([]*gocloak.Group, error) {
	ret := _m.Called(ctx, accessToken, realm, userID, params)

	var r0 []*gocloak.Group
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.GetGroupsParams) []*gocloak.Group); ok {
		r0 = rf(ctx, accessToken, realm, userID, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, gocloak.GetGroupsParams) error); ok {
		r1 = rf(ctx, accessToken, realm, userID, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserInfo provides a mock function with given fields: ctx, accessToken, realm
func (_m *GoCloak) GetUserInfo(ctx context.Context, accessToken string, realm string) (*gocloak.UserInfo, error) {
	ret := _m.Called(ctx, accessToken, realm)

	var r0 *gocloak.UserInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *gocloak.UserInfo); ok {
		r0 = rf(ctx, accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.UserInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserOfflineSessionsForClient provides a mock function with given fields: ctx, token, realm, userID, idOfClient
func (_m *GoCloak) GetUserOfflineSessionsForClient(ctx context.Context, token string, realm string, userID string, idOfClient string) ([]*gocloak.UserSessionRepresentation, error) {
	ret := _m.Called(ctx, token, realm, userID, idOfClient)

	var r0 []*gocloak.UserSessionRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []*gocloak.UserSessionRepresentation); ok {
		r0 = rf(ctx, token, realm, userID, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.UserSessionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, userID, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserPermissions provides a mock function with given fields: ctx, token, realm, params
func (_m *GoCloak) GetUserPermissions(ctx context.Context, token string, realm string, params gocloak.GetUserPermissionParams) ([]*gocloak.PermissionGrantResponseRepresentation, error) {
	ret := _m.Called(ctx, token, realm, params)

	var r0 []*gocloak.PermissionGrantResponseRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetUserPermissionParams) []*gocloak.PermissionGrantResponseRepresentation); ok {
		r0 = rf(ctx, token, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PermissionGrantResponseRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetUserPermissionParams) error); ok {
		r1 = rf(ctx, token, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserSessions provides a mock function with given fields: ctx, token, realm, userID
func (_m *GoCloak) GetUserSessions(ctx context.Context, token string, realm string, userID string) ([]*gocloak.UserSessionRepresentation, error) {
	ret := _m.Called(ctx, token, realm, userID)

	var r0 []*gocloak.UserSessionRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.UserSessionRepresentation); ok {
		r0 = rf(ctx, token, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.UserSessionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsers provides a mock function with given fields: ctx, accessToken, realm, params
func (_m *GoCloak) GetUsers(ctx context.Context, accessToken string, realm string, params gocloak.GetUsersParams) ([]*gocloak.User, error) {
	ret := _m.Called(ctx, accessToken, realm, params)

	var r0 []*gocloak.User
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.GetUsersParams) []*gocloak.User); ok {
		r0 = rf(ctx, accessToken, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.GetUsersParams) error); ok {
		r1 = rf(ctx, accessToken, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsersByClientRoleName provides a mock function with given fields: ctx, token, realm, idOfClient, roleName, params
func (_m *GoCloak) GetUsersByClientRoleName(ctx context.Context, token string, realm string, idOfClient string, roleName string, params gocloak.GetUsersByRoleParams) ([]*gocloak.User, error) {
	ret := _m.Called(ctx, token, realm, idOfClient, roleName, params)

	var r0 []*gocloak.User
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, gocloak.GetUsersByRoleParams) []*gocloak.User); ok {
		r0 = rf(ctx, token, realm, idOfClient, roleName, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, gocloak.GetUsersByRoleParams) error); ok {
		r1 = rf(ctx, token, realm, idOfClient, roleName, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsersByRoleName provides a mock function with given fields: ctx, token, realm, roleName
func (_m *GoCloak) GetUsersByRoleName(ctx context.Context, token string, realm string, roleName string) ([]*gocloak.User, error) {
	ret := _m.Called(ctx, token, realm, roleName)

	var r0 []*gocloak.User
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []*gocloak.User); ok {
		r0 = rf(ctx, token, realm, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GrantUserPermission provides a mock function with given fields: ctx, token, realm, permission
func (_m *GoCloak) GrantUserPermission(ctx context.Context, token string, realm string, permission gocloak.PermissionGrantParams) (*gocloak.PermissionGrantResponseRepresentation, error) {
	ret := _m.Called(ctx, token, realm, permission)

	var r0 *gocloak.PermissionGrantResponseRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.PermissionGrantParams) *gocloak.PermissionGrantResponseRepresentation); ok {
		r0 = rf(ctx, token, realm, permission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PermissionGrantResponseRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.PermissionGrantParams) error); ok {
		r1 = rf(ctx, token, realm, permission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportIdentityProviderConfig provides a mock function with given fields: ctx, token, realm, fromURL, providerID
func (_m *GoCloak) ImportIdentityProviderConfig(ctx context.Context, token string, realm string, fromURL string, providerID string) (map[string]string, error) {
	ret := _m.Called(ctx, token, realm, fromURL, providerID)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) map[string]string); ok {
		r0 = rf(ctx, token, realm, fromURL, providerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, fromURL, providerID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportIdentityProviderConfigFromFile provides a mock function with given fields: ctx, token, realm, providerID, fileName, fileBody
func (_m *GoCloak) ImportIdentityProviderConfigFromFile(ctx context.Context, token string, realm string, providerID string, fileName string, fileBody io.Reader) (map[string]string, error) {
	ret := _m.Called(ctx, token, realm, providerID, fileName, fileBody)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, io.Reader) map[string]string); ok {
		r0 = rf(ctx, token, realm, providerID, fileName, fileBody)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, io.Reader) error); ok {
		r1 = rf(ctx, token, realm, providerID, fileName, fileBody)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Login provides a mock function with given fields: ctx, clientID, clientSecret, realm, username, password
func (_m *GoCloak) Login(ctx context.Context, clientID string, clientSecret string, realm string, username string, password string) (*gocloak.JWT, error) {
	ret := _m.Called(ctx, clientID, clientSecret, realm, username, password)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string) *gocloak.JWT); ok {
		r0 = rf(ctx, clientID, clientSecret, realm, username, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, string) error); ok {
		r1 = rf(ctx, clientID, clientSecret, realm, username, password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginAdmin provides a mock function with given fields: ctx, username, password, realm
func (_m *GoCloak) LoginAdmin(ctx context.Context, username string, password string, realm string) (*gocloak.JWT, error) {
	ret := _m.Called(ctx, username, password, realm)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.JWT); ok {
		r0 = rf(ctx, username, password, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, username, password, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginClient provides a mock function with given fields: ctx, clientID, clientSecret, realm
func (_m *GoCloak) LoginClient(ctx context.Context, clientID string, clientSecret string, realm string) (*gocloak.JWT, error) {
	ret := _m.Called(ctx, clientID, clientSecret, realm)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.JWT); ok {
		r0 = rf(ctx, clientID, clientSecret, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, clientID, clientSecret, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginClientSignedJWT provides a mock function with given fields: ctx, idOfClient, realm, key, signedMethod, expiresAt
func (_m *GoCloak) LoginClientSignedJWT(ctx context.Context, idOfClient string, realm string, key interface{}, signedMethod jwt.SigningMethod, expiresAt *jwt.NumericDate) (*gocloak.JWT, error) {
	ret := _m.Called(ctx, idOfClient, realm, key, signedMethod, expiresAt)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}, jwt.SigningMethod, *jwt.NumericDate) *gocloak.JWT); ok {
		r0 = rf(ctx, idOfClient, realm, key, signedMethod, expiresAt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, interface{}, jwt.SigningMethod, *jwt.NumericDate) error); ok {
		r1 = rf(ctx, idOfClient, realm, key, signedMethod, expiresAt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginClientTokenExchange provides a mock function with given fields: ctx, clientID, token, clientSecret, realm, targetClient, userID
func (_m *GoCloak) LoginClientTokenExchange(ctx context.Context, clientID string, token string, clientSecret string, realm string, targetClient string, userID string) (*gocloak.JWT, error) {
	ret := _m.Called(ctx, clientID, token, clientSecret, realm, targetClient, userID)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string) *gocloak.JWT); ok {
		r0 = rf(ctx, clientID, token, clientSecret, realm, targetClient, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, string) error); ok {
		r1 = rf(ctx, clientID, token, clientSecret, realm, targetClient, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginOtp provides a mock function with given fields: ctx, clientID, clientSecret, realm, username, password, totp
func (_m *GoCloak) LoginOtp(ctx context.Context, clientID string, clientSecret string, realm string, username string, password string, totp string) (*gocloak.JWT, error) {
	ret := _m.Called(ctx, clientID, clientSecret, realm, username, password, totp)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string) *gocloak.JWT); ok {
		r0 = rf(ctx, clientID, clientSecret, realm, username, password, totp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, string) error); ok {
		r1 = rf(ctx, clientID, clientSecret, realm, username, password, totp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Logout provides a mock function with given fields: ctx, clientID, clientSecret, realm, refreshToken
func (_m *GoCloak) Logout(ctx context.Context, clientID string, clientSecret string, realm string, refreshToken string) error {
	ret := _m.Called(ctx, clientID, clientSecret, realm, refreshToken)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, clientID, clientSecret, realm, refreshToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogoutAllSessions provides a mock function with given fields: ctx, accessToken, realm, userID
func (_m *GoCloak) LogoutAllSessions(ctx context.Context, accessToken string, realm string, userID string) error {
	ret := _m.Called(ctx, accessToken, realm, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogoutPublicClient provides a mock function with given fields: ctx, idOfClient, realm, accessToken, refreshToken
func (_m *GoCloak) LogoutPublicClient(ctx context.Context, idOfClient string, realm string, accessToken string, refreshToken string) error {
	ret := _m.Called(ctx, idOfClient, realm, accessToken, refreshToken)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, idOfClient, realm, accessToken, refreshToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogoutUserSession provides a mock function with given fields: ctx, accessToken, realm, session
func (_m *GoCloak) LogoutUserSession(ctx context.Context, accessToken string, realm string, session string) error {
	ret := _m.Called(ctx, accessToken, realm, session)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, session)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MoveCredentialBehind provides a mock function with given fields: ctx, token, realm, userID, credentialID, newPreviousCredentialID
func (_m *GoCloak) MoveCredentialBehind(ctx context.Context, token string, realm string, userID string, credentialID string, newPreviousCredentialID string) error {
	ret := _m.Called(ctx, token, realm, userID, credentialID, newPreviousCredentialID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, userID, credentialID, newPreviousCredentialID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MoveCredentialToFirst provides a mock function with given fields: ctx, token, realm, userID, credentialID
func (_m *GoCloak) MoveCredentialToFirst(ctx context.Context, token string, realm string, userID string, credentialID string) error {
	ret := _m.Called(ctx, token, realm, userID, credentialID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, userID, credentialID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RefreshToken provides a mock function with given fields: ctx, refreshToken, clientID, clientSecret, realm
func (_m *GoCloak) RefreshToken(ctx context.Context, refreshToken string, clientID string, clientSecret string, realm string) (*gocloak.JWT, error) {
	ret := _m.Called(ctx, refreshToken, clientID, clientSecret, realm)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *gocloak.JWT); ok {
		r0 = rf(ctx, refreshToken, clientID, clientSecret, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, refreshToken, clientID, clientSecret, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegenerateClientSecret provides a mock function with given fields: ctx, token, realm, idOfClient
func (_m *GoCloak) RegenerateClientSecret(ctx context.Context, token string, realm string, idOfClient string) (*gocloak.CredentialRepresentation, error) {
	ret := _m.Called(ctx, token, realm, idOfClient)

	var r0 *gocloak.CredentialRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.CredentialRepresentation); ok {
		r0 = rf(ctx, token, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.CredentialRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, token, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveDefaultGroup provides a mock function with given fields: ctx, accessToken, realm, groupID
func (_m *GoCloak) RemoveDefaultGroup(ctx context.Context, accessToken string, realm string, groupID string) error {
	ret := _m.Called(ctx, accessToken, realm, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveDefaultScopeFromClient provides a mock function with given fields: ctx, token, realm, idOfClient, scopeID
func (_m *GoCloak) RemoveDefaultScopeFromClient(ctx context.Context, token string, realm string, idOfClient string, scopeID string) error {
	ret := _m.Called(ctx, token, realm, idOfClient, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveOptionalScopeFromClient provides a mock function with given fields: ctx, token, realm, idOfClient, scopeID
func (_m *GoCloak) RemoveOptionalScopeFromClient(ctx context.Context, token string, realm string, idOfClient string, scopeID string) error {
	ret := _m.Called(ctx, token, realm, idOfClient, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestyClient provides a mock function with given fields:
func (_m *GoCloak) RestyClient() *resty.Client {
	ret := _m.Called()

	var r0 *resty.Client
	if rf, ok := ret.Get(0).(func() *resty.Client); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*resty.Client)
		}
	}

	return r0
}

// RetrospectToken provides a mock function with given fields: ctx, accessToken, clientID, clientSecret, realm
func (_m *GoCloak) RetrospectToken(ctx context.Context, accessToken string, clientID string, clientSecret string, realm string) (*gocloak.RetrospecTokenResult, error) {
	ret := _m.Called(ctx, accessToken, clientID, clientSecret, realm)

	var r0 *gocloak.RetrospecTokenResult
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *gocloak.RetrospecTokenResult); ok {
		r0 = rf(ctx, accessToken, clientID, clientSecret, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.RetrospecTokenResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, accessToken, clientID, clientSecret, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeUserConsents provides a mock function with given fields: ctx, accessToken, realm, userID, clientID
func (_m *GoCloak) RevokeUserConsents(ctx context.Context, accessToken string, realm string, userID string, clientID string) error {
	ret := _m.Called(ctx, accessToken, realm, userID, clientID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, accessToken, realm, userID, clientID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetPassword provides a mock function with given fields: ctx, token, userID, realm, password, temporary
func (_m *GoCloak) SetPassword(ctx context.Context, token string, userID string, realm string, password string, temporary bool) error {
	ret := _m.Called(ctx, token, userID, realm, password, temporary)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, bool) error); ok {
		r0 = rf(ctx, token, userID, realm, password, temporary)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetRestyClient provides a mock function with given fields: restyClient
func (_m *GoCloak) SetRestyClient(restyClient *resty.Client) {
	_m.Called(restyClient)
}

// UpdateAuthenticationExecution provides a mock function with given fields: ctx, token, realm, flow, execution
func (_m *GoCloak) UpdateAuthenticationExecution(ctx context.Context, token string, realm string, flow string, execution gocloak.ModifyAuthenticationExecutionRepresentation) error {
	ret := _m.Called(ctx, token, realm, flow, execution)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ModifyAuthenticationExecutionRepresentation) error); ok {
		r0 = rf(ctx, token, realm, flow, execution)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateClient provides a mock function with given fields: ctx, accessToken, realm, updatedClient
func (_m *GoCloak) UpdateClient(ctx context.Context, accessToken string, realm string, updatedClient gocloak.Client) error {
	ret := _m.Called(ctx, accessToken, realm, updatedClient)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.Client) error); ok {
		r0 = rf(ctx, accessToken, realm, updatedClient)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateClientProtocolMapper provides a mock function with given fields: ctx, token, realm, idOfClient, mapperID, mapper
func (_m *GoCloak) UpdateClientProtocolMapper(ctx context.Context, token string, realm string, idOfClient string, mapperID string, mapper gocloak.ProtocolMapperRepresentation) error {
	ret := _m.Called(ctx, token, realm, idOfClient, mapperID, mapper)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, gocloak.ProtocolMapperRepresentation) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, mapperID, mapper)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateClientRepresentation provides a mock function with given fields: ctx, accessToken, realm, updatedClient
func (_m *GoCloak) UpdateClientRepresentation(ctx context.Context, accessToken string, realm string, updatedClient gocloak.Client) (*gocloak.Client, error) {
	ret := _m.Called(ctx, accessToken, realm, updatedClient)

	var r0 *gocloak.Client
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.Client) *gocloak.Client); ok {
		r0 = rf(ctx, accessToken, realm, updatedClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.Client) error); ok {
		r1 = rf(ctx, accessToken, realm, updatedClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClientScope provides a mock function with given fields: ctx, accessToken, realm, scope
func (_m *GoCloak) UpdateClientScope(ctx context.Context, accessToken string, realm string, scope gocloak.ClientScope) error {
	ret := _m.Called(ctx, accessToken, realm, scope)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.ClientScope) error); ok {
		r0 = rf(ctx, accessToken, realm, scope)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateClientScopeProtocolMapper provides a mock function with given fields: ctx, accessToken, realm, scopeID, protocolMapper
func (_m *GoCloak) UpdateClientScopeProtocolMapper(ctx context.Context, accessToken string, realm string, scopeID string, protocolMapper gocloak.ProtocolMappers) error {
	ret := _m.Called(ctx, accessToken, realm, scopeID, protocolMapper)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ProtocolMappers) error); ok {
		r0 = rf(ctx, accessToken, realm, scopeID, protocolMapper)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCredentialUserLabel provides a mock function with given fields: ctx, token, realm, userID, credentialID, userLabel
func (_m *GoCloak) UpdateCredentialUserLabel(ctx context.Context, token string, realm string, userID string, credentialID string, userLabel string) error {
	ret := _m.Called(ctx, token, realm, userID, credentialID, userLabel)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string) error); ok {
		r0 = rf(ctx, token, realm, userID, credentialID, userLabel)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateGroup provides a mock function with given fields: ctx, accessToken, realm, updatedGroup
func (_m *GoCloak) UpdateGroup(ctx context.Context, accessToken string, realm string, updatedGroup gocloak.Group) error {
	ret := _m.Called(ctx, accessToken, realm, updatedGroup)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.Group) error); ok {
		r0 = rf(ctx, accessToken, realm, updatedGroup)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateIdentityProvider provides a mock function with given fields: ctx, token, realm, alias, providerRep
func (_m *GoCloak) UpdateIdentityProvider(ctx context.Context, token string, realm string, alias string, providerRep gocloak.IdentityProviderRepresentation) error {
	ret := _m.Called(ctx, token, realm, alias, providerRep)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.IdentityProviderRepresentation) error); ok {
		r0 = rf(ctx, token, realm, alias, providerRep)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateIdentityProviderMapper provides a mock function with given fields: ctx, token, realm, alias, mapper
func (_m *GoCloak) UpdateIdentityProviderMapper(ctx context.Context, token string, realm string, alias string, mapper gocloak.IdentityProviderMapper) error {
	ret := _m.Called(ctx, token, realm, alias, mapper)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.IdentityProviderMapper) error); ok {
		r0 = rf(ctx, token, realm, alias, mapper)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdatePermission provides a mock function with given fields: ctx, token, realm, idOfClient, permission
func (_m *GoCloak) UpdatePermission(ctx context.Context, token string, realm string, idOfClient string, permission gocloak.PermissionRepresentation) error {
	ret := _m.Called(ctx, token, realm, idOfClient, permission)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.PermissionRepresentation) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, permission)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdatePolicy provides a mock function with given fields: ctx, token, realm, idOfClient, policy
func (_m *GoCloak) UpdatePolicy(ctx context.Context, token string, realm string, idOfClient string, policy gocloak.PolicyRepresentation) error {
	ret := _m.Called(ctx, token, realm, idOfClient, policy)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.PolicyRepresentation) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, policy)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRealm provides a mock function with given fields: ctx, token, realm
func (_m *GoCloak) UpdateRealm(ctx context.Context, token string, realm gocloak.RealmRepresentation) error {
	ret := _m.Called(ctx, token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, gocloak.RealmRepresentation) error); ok {
		r0 = rf(ctx, token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRealmRole provides a mock function with given fields: ctx, token, realm, roleName, role
func (_m *GoCloak) UpdateRealmRole(ctx context.Context, token string, realm string, roleName string, role gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, roleName, role)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, roleName, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRealmRoleByID provides a mock function with given fields: ctx, token, realm, roleID, role
func (_m *GoCloak) UpdateRealmRoleByID(ctx context.Context, token string, realm string, roleID string, role gocloak.Role) error {
	ret := _m.Called(ctx, token, realm, roleID, role)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.Role) error); ok {
		r0 = rf(ctx, token, realm, roleID, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRequiredAction provides a mock function with given fields: ctx, token, realm, requiredAction
func (_m *GoCloak) UpdateRequiredAction(ctx context.Context, token string, realm string, requiredAction gocloak.RequiredActionProviderRepresentation) error {
	ret := _m.Called(ctx, token, realm, requiredAction)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.RequiredActionProviderRepresentation) error); ok {
		r0 = rf(ctx, token, realm, requiredAction)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateResource provides a mock function with given fields: ctx, token, realm, idOfClient, resource
func (_m *GoCloak) UpdateResource(ctx context.Context, token string, realm string, idOfClient string, resource gocloak.ResourceRepresentation) error {
	ret := _m.Called(ctx, token, realm, idOfClient, resource)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ResourceRepresentation) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, resource)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateResourceClient provides a mock function with given fields: ctx, token, realm, resource
func (_m *GoCloak) UpdateResourceClient(ctx context.Context, token string, realm string, resource gocloak.ResourceRepresentation) error {
	ret := _m.Called(ctx, token, realm, resource)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.ResourceRepresentation) error); ok {
		r0 = rf(ctx, token, realm, resource)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateResourcePolicy provides a mock function with given fields: ctx, token, realm, permissionID, policy
func (_m *GoCloak) UpdateResourcePolicy(ctx context.Context, token string, realm string, permissionID string, policy gocloak.ResourcePolicyRepresentation) error {
	ret := _m.Called(ctx, token, realm, permissionID, policy)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ResourcePolicyRepresentation) error); ok {
		r0 = rf(ctx, token, realm, permissionID, policy)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRole provides a mock function with given fields: ctx, accessToken, realm, idOfClient, role
func (_m *GoCloak) UpdateRole(ctx context.Context, accessToken string, realm string, idOfClient string, role gocloak.Role) error {
	ret := _m.Called(ctx, accessToken, realm, idOfClient, role)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.Role) error); ok {
		r0 = rf(ctx, accessToken, realm, idOfClient, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateScope provides a mock function with given fields: ctx, token, realm, idOfClient, resource
func (_m *GoCloak) UpdateScope(ctx context.Context, token string, realm string, idOfClient string, resource gocloak.ScopeRepresentation) error {
	ret := _m.Called(ctx, token, realm, idOfClient, resource)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, gocloak.ScopeRepresentation) error); ok {
		r0 = rf(ctx, token, realm, idOfClient, resource)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateUser provides a mock function with given fields: ctx, accessToken, realm, user
func (_m *GoCloak) UpdateUser(ctx context.Context, accessToken string, realm string, user gocloak.User) error {
	ret := _m.Called(ctx, accessToken, realm, user)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.User) error); ok {
		r0 = rf(ctx, accessToken, realm, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateUserPermission provides a mock function with given fields: ctx, token, realm, permission
func (_m *GoCloak) UpdateUserPermission(ctx context.Context, token string, realm string, permission gocloak.PermissionGrantParams) (*gocloak.PermissionGrantResponseRepresentation, error) {
	ret := _m.Called(ctx, token, realm, permission)

	var r0 *gocloak.PermissionGrantResponseRepresentation
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.PermissionGrantParams) *gocloak.PermissionGrantResponseRepresentation); ok {
		r0 = rf(ctx, token, realm, permission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PermissionGrantResponseRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.PermissionGrantParams) error); ok {
		r1 = rf(ctx, token, realm, permission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewGoCloak interface {
	mock.TestingT
	Cleanup(func())
}

// NewGoCloak creates a new instance of GoCloak. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewGoCloak(t mockConstructorTestingTNewGoCloak) *GoCloak {
	mock := &GoCloak{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
